{
    "docs": [
        {
            "location": "/", 
            "text": "eac.js\n\n\nA library and a command line execution tool for working with the \nEthereum Alarm Clock\n protocol. \n\n\nInstall\n\n\nAs an executable\n\n\nThe \neac.js\n executable can be downloaded from NPM. \n\n\n$ npm i -g eac.js\n\n\n\n\nPlease proceed to \nExecuting\n for a walkthrough on how to get started.\n\n\nAs a library\n\n\nIf you are using eac.js as a library you will want to download it into your \npackage.json\n file.\n\n\n$ npm i eac.js --save\n\n\n\n\nProceed to the \nAPI\n reference.", 
            "title": "Home"
        }, 
        {
            "location": "/#eacjs", 
            "text": "A library and a command line execution tool for working with the  Ethereum Alarm Clock  protocol.", 
            "title": "eac.js"
        }, 
        {
            "location": "/#install", 
            "text": "", 
            "title": "Install"
        }, 
        {
            "location": "/#as-an-executable", 
            "text": "The  eac.js  executable can be downloaded from NPM.   $ npm i -g eac.js  Please proceed to  Executing  for a walkthrough on how to get started.", 
            "title": "As an executable"
        }, 
        {
            "location": "/#as-a-library", 
            "text": "If you are using eac.js as a library you will want to download it into your  package.json  file.  $ npm i eac.js --save  Proceed to the  API  reference.", 
            "title": "As a library"
        }, 
        {
            "location": "/Executing_Tut/", 
            "text": "Running an Execution client with eac.js\n\n\nOne of the things you can do with the eac.js commandline tool\nis run an execution client. This client will scan the blockchain \nlooking for upcoming transaction requests and attempt to claim and \nexecute them. If the client successfully executes a transaction, it will\nbe rewarded with the \npayment\n that was set by the scheduler as well\nas reimbursed for all the gas costs. \n\n\nNote: Currenlty eac.js is only available for the Ropsten testnet and only\nworks on a parity local node.\n\n\nSetting up a Parity local node\n\n\nTo run the execution client while it is in beta requires the set up of a \nParity local node on the Ropsten test network. This requirement is due to \nthe fact that the client relies on a Parity-specific API for checking\nthe transaction pool for existing calls to contracts. Without this \nRPC call, the client will try to send transactions on top of other clients\nwhich would invetibly lead to one of those calls being denied and thereby\nlosing the client some gas fees. You can download Parity by following the \ninstructions on their \ngithub\n.\n\n\nFor the sake of this tutorial, we will be using the Ropsten network, but all\nthe commands should work by specifying the Kovan network just as well.\n\n\nWe begin by creating a new account.\n\n\n$ parity --chain ropsten account new\n\n\n\n\nThe command will prompt you to enter a new password. As with any password,\nmake sure you keep it in a secure place and do not lose it. It will also\nprint the address of your new ethereum account to the console. The next\ntime you start the parity client, and every time thereafter you will have\nto pass a command to make sure that this account is unlocked and able to\nsign and send transaction. You will also want to create a text file and save\npassword in it since parity requires it to unlock the account. Try \nrestarting parity again and unlocking the account:\n\n\n$ parity --geth --chain ropsten --unlock \nYOUR ACCOUNT\n --password \nPASSWORD FILE\n\n\n\n\n\nParity should continue syncing with your account unlocked. Your next\nsteps should be finding a source for some Kovan Ether, we recommend asking\non the Kovan Faucet Gitter chat, they're usually responsive! If that doesn't work \ntrying pinging @lsaether on Gitter or asking in the Ethereum Alarm Clock room.\n\n\nRunning the client\n\n\nYou can run the client using just your default account by simply passing the\n\n-c\n option to eac.js. The tool will automatically pickup which network you\nare using. It will drop you into a REPL that has a few speciic commands to\nhelp with interacting with the EAC.\n\n\n$ eac.js -c\n\u23f0\u23f0\u23f0 Welcome to the Ethereum Alarm Clock client \u23f0\u23f0\u23f0\n\nWallet support: Disabled\n\nExecuting from account:\n0x009f7EfeD908c05df5101DA1557b7CaaB38EE4Ce | Balance: 62.055242795864837678\n\n\n\n\n\n\n\nThe REPL is an important aspect of the eac.js tool and provides you\nwith a set of specific commands that will help you in interacting with\nand executing on the Ethereum Alarm Clock contracts. The EAC-centric commands \nyou can pass to this REPL are below:\n\n\n.dumpCache    Dumps your cache storage.\n.getBalance   Get the balance of your accounts.\n.getBlock     Get the latest blockNum and timestamp.\n.getStats     Get some interesting stats on your executing accounts.\n.logLevel     Defines the level to log, 1 - debug/cache, 2 - info, 3 - error.\n.start        Starts the execution client.\n.stop         Stops the execution client.\n.sweepCache   Sweeps your cache of expired txRequests.\n.testTx       Send a test transaction to the network (requires unlocked local account).\n\n\n\n\nThe most important commands are probably \n.start\n and \n.stop\n which \nrespectively begins and pauses the execution clients. When you begin\nexecuting, you client will search the blockchain for upcoming transaction\nrequests registered with the Ethereum Alarm Clock contracts and store them\nin your local cache. It will then periodically scan your cache for actionable\ntransaction requests and perform one of three actions on them: claim, execute, or\ncleanup. If one of your accounts executes a transaction, it will earn money. You\ncan check on the stats of your executing accounts at any time by using the\n\n.getStats\n command. Likewise, you can view the contents of your cache by\nusing the \n.dumpCache\n command and if you would like to clear away old requests,\nuse \n.sweepCache\n (although the client will do this automatically every 12 minutes).\n\n\nIf you notice that the blockchain is sparse of upcoming transactions, you can \npopulate a test transaction by using the command \n.testTx\n. Note! This will use\nyour default unlocked account to send a transaction to the network so make sure\nyou have enough testnet ether in your account to do this.\n\n\nAnd that's all there is to it. If you have any questions please join us on Gitter,\nor raise an issue on Github. Thanks for using the tool! \ud83d\ude42", 
            "title": "Executing"
        }, 
        {
            "location": "/Executing_Tut/#running-an-execution-client-with-eacjs", 
            "text": "One of the things you can do with the eac.js commandline tool\nis run an execution client. This client will scan the blockchain \nlooking for upcoming transaction requests and attempt to claim and \nexecute them. If the client successfully executes a transaction, it will\nbe rewarded with the  payment  that was set by the scheduler as well\nas reimbursed for all the gas costs.   Note: Currenlty eac.js is only available for the Ropsten testnet and only\nworks on a parity local node.", 
            "title": "Running an Execution client with eac.js"
        }, 
        {
            "location": "/Executing_Tut/#setting-up-a-parity-local-node", 
            "text": "To run the execution client while it is in beta requires the set up of a \nParity local node on the Ropsten test network. This requirement is due to \nthe fact that the client relies on a Parity-specific API for checking\nthe transaction pool for existing calls to contracts. Without this \nRPC call, the client will try to send transactions on top of other clients\nwhich would invetibly lead to one of those calls being denied and thereby\nlosing the client some gas fees. You can download Parity by following the \ninstructions on their  github .  For the sake of this tutorial, we will be using the Ropsten network, but all\nthe commands should work by specifying the Kovan network just as well.  We begin by creating a new account.  $ parity --chain ropsten account new  The command will prompt you to enter a new password. As with any password,\nmake sure you keep it in a secure place and do not lose it. It will also\nprint the address of your new ethereum account to the console. The next\ntime you start the parity client, and every time thereafter you will have\nto pass a command to make sure that this account is unlocked and able to\nsign and send transaction. You will also want to create a text file and save\npassword in it since parity requires it to unlock the account. Try \nrestarting parity again and unlocking the account:  $ parity --geth --chain ropsten --unlock  YOUR ACCOUNT  --password  PASSWORD FILE   Parity should continue syncing with your account unlocked. Your next\nsteps should be finding a source for some Kovan Ether, we recommend asking\non the Kovan Faucet Gitter chat, they're usually responsive! If that doesn't work \ntrying pinging @lsaether on Gitter or asking in the Ethereum Alarm Clock room.", 
            "title": "Setting up a Parity local node"
        }, 
        {
            "location": "/Executing_Tut/#running-the-client", 
            "text": "You can run the client using just your default account by simply passing the -c  option to eac.js. The tool will automatically pickup which network you\nare using. It will drop you into a REPL that has a few speciic commands to\nhelp with interacting with the EAC.  $ eac.js -c\n\u23f0\u23f0\u23f0 Welcome to the Ethereum Alarm Clock client \u23f0\u23f0\u23f0\n\nWallet support: Disabled\n\nExecuting from account:\n0x009f7EfeD908c05df5101DA1557b7CaaB38EE4Ce | Balance: 62.055242795864837678   The REPL is an important aspect of the eac.js tool and provides you\nwith a set of specific commands that will help you in interacting with\nand executing on the Ethereum Alarm Clock contracts. The EAC-centric commands \nyou can pass to this REPL are below:  .dumpCache    Dumps your cache storage.\n.getBalance   Get the balance of your accounts.\n.getBlock     Get the latest blockNum and timestamp.\n.getStats     Get some interesting stats on your executing accounts.\n.logLevel     Defines the level to log, 1 - debug/cache, 2 - info, 3 - error.\n.start        Starts the execution client.\n.stop         Stops the execution client.\n.sweepCache   Sweeps your cache of expired txRequests.\n.testTx       Send a test transaction to the network (requires unlocked local account).  The most important commands are probably  .start  and  .stop  which \nrespectively begins and pauses the execution clients. When you begin\nexecuting, you client will search the blockchain for upcoming transaction\nrequests registered with the Ethereum Alarm Clock contracts and store them\nin your local cache. It will then periodically scan your cache for actionable\ntransaction requests and perform one of three actions on them: claim, execute, or\ncleanup. If one of your accounts executes a transaction, it will earn money. You\ncan check on the stats of your executing accounts at any time by using the .getStats  command. Likewise, you can view the contents of your cache by\nusing the  .dumpCache  command and if you would like to clear away old requests,\nuse  .sweepCache  (although the client will do this automatically every 12 minutes).  If you notice that the blockchain is sparse of upcoming transactions, you can \npopulate a test transaction by using the command  .testTx . Note! This will use\nyour default unlocked account to send a transaction to the network so make sure\nyou have enough testnet ether in your account to do this.  And that's all there is to it. If you have any questions please join us on Gitter,\nor raise an issue on Github. Thanks for using the tool! \ud83d\ude42", 
            "title": "Running the client"
        }, 
        {
            "location": "/API/", 
            "text": "API Documentation\n\n\nThe eac.js library provides utilies to interact with the Ethereum Alarm Clock contracts.\nIt exposes a few endpoints which mainly provide convenience wrappers over\nthe essiential functions of the contracts. \n\n\nIn general you will simply \nnpm install\n the \neac.js\n package then \nrequire\n it in your source file like so:\n\n\nconst eac = require('eac.js')", 
            "title": "API Documentation"
        }, 
        {
            "location": "/API/#api-documentation", 
            "text": "The eac.js library provides utilies to interact with the Ethereum Alarm Clock contracts.\nIt exposes a few endpoints which mainly provide convenience wrappers over\nthe essiential functions of the contracts.   In general you will simply  npm install  the  eac.js  package then  require  it in your source file like so:  const eac = require('eac.js')", 
            "title": "API Documentation"
        }, 
        {
            "location": "/API/constants/", 
            "text": "eac.Constants\n\n\nconsole.log(eac.Constants)\n\n{\n    GT_HEX: '0x3e',\n    LT_HEX: '0x3c',\n    GTE_HEX: '0x3e3d',\n    LTE_HEX: '0x3c3d',\n    EQ_HEX: '0x3d3d',\n    NULL_ADDRESS: '0x0000000000000000000000000000000000000000',\n    EXECUTEDLOG: '0x3e504bb8b225ad41f613b0c3c4205cdd752d1615b4d77cd1773417282fcfb5d9',\n    ABORTEDLOG: '0xc008bc849b42227c61d5063a1313ce509a6e99211bfd59e827e417be6c65c81b'\n}", 
            "title": "Constants"
        }, 
        {
            "location": "/API/constants/#eacconstants", 
            "text": "console.log(eac.Constants)\n\n{\n    GT_HEX: '0x3e',\n    LT_HEX: '0x3c',\n    GTE_HEX: '0x3e3d',\n    LTE_HEX: '0x3c3d',\n    EQ_HEX: '0x3d3d',\n    NULL_ADDRESS: '0x0000000000000000000000000000000000000000',\n    EXECUTEDLOG: '0x3e504bb8b225ad41f613b0c3c4205cdd752d1615b4d77cd1773417282fcfb5d9',\n    ABORTEDLOG: '0xc008bc849b42227c61d5063a1313ce509a6e99211bfd59e827e417be6c65c81b'\n}", 
            "title": "eac.Constants"
        }, 
        {
            "location": "/API/requestFactory/", 
            "text": "eac.RequestFactory\n\n\nExposes utilities for interacting with the Request Factory contract.\n\n\nConstructor\n\n\nCreates a new instance of a \neac.RequestFactory\n and takes two arguments, the\nfirst is the \naddress\n of the request factory contract and the second is a \nweb3\n object.\n\n\nconst requestFactory = new eac.RequestFactory(address, web3)\n\n\n\n\nYou can also instantiate a new requestFactory using the convenience functions.\n\n\neac.RequestFactory.initMainnet(web3)\n\n\nTakes a \nweb3\n object and returns the new instance of a \neac.RequestFactory\n instantiated for \nthe mainnet chain.\n\n\neac.RequestFactory.initRopsten(web3)\n\n\nTakes a \nweb3\n object and returns the new instance of a \neac.RequestFactory\n instatiated for the ropsten\nchain.\n\n\nconst requestFactory = eac.RequestFactory.initRopsten(web3)\n\n// You now have a fully instantiated instance which will\n// automatically use the canonical Ropsten contracts.\n\n\n\n\neac.RequestFactory.getTrackerAddress()\n\n\nReturns the \naddress\n of the tracker that the request factory is using\nto track new transaction requests. Can then pass the address to create a new instance of a \neac.RequestTracker\n.\n\n\nconst trackerAddr = requestFactory.getTrackerAddress()\nconst requestTracker = new eac.RequestTracker(trackerAddr, web3)\nrequestTracker.setFactory(requestFactory.address)\n\n// You now have a requestTracker that is the one connected to the\n// requestFactory.\n\n\n\n\neac.RequestFactory.isKnownRequest(requestAddr)\n\n\nTakes a \nTxRequest\n address and returns a \nPromise\n that will resolve \ntrue\n if the transaction request\nis registed with the factory and \nfalse\n if it's not. This function is used\nby clients to verify that the address was registered through the watched\ncontracts.\n\n\n// Verify that the request is known to the factory we are validating with.\nif (!await requestFactory.isKnownRequest(nextRequestAddress)) {\n    throw new Error(`Encountered unknown address! Please check that you are using the correct contracts JSON file.`)\n}", 
            "title": "Request Factory"
        }, 
        {
            "location": "/API/requestFactory/#eacrequestfactory", 
            "text": "Exposes utilities for interacting with the Request Factory contract.", 
            "title": "eac.RequestFactory"
        }, 
        {
            "location": "/API/requestFactory/#constructor", 
            "text": "Creates a new instance of a  eac.RequestFactory  and takes two arguments, the\nfirst is the  address  of the request factory contract and the second is a  web3  object.  const requestFactory = new eac.RequestFactory(address, web3)  You can also instantiate a new requestFactory using the convenience functions.", 
            "title": "Constructor"
        }, 
        {
            "location": "/API/requestFactory/#eacrequestfactoryinitmainnetweb3", 
            "text": "Takes a  web3  object and returns the new instance of a  eac.RequestFactory  instantiated for \nthe mainnet chain.", 
            "title": "eac.RequestFactory.initMainnet(web3)"
        }, 
        {
            "location": "/API/requestFactory/#eacrequestfactoryinitropstenweb3", 
            "text": "Takes a  web3  object and returns the new instance of a  eac.RequestFactory  instatiated for the ropsten\nchain.  const requestFactory = eac.RequestFactory.initRopsten(web3)\n\n// You now have a fully instantiated instance which will\n// automatically use the canonical Ropsten contracts.", 
            "title": "eac.RequestFactory.initRopsten(web3)"
        }, 
        {
            "location": "/API/requestFactory/#eacrequestfactorygettrackeraddress", 
            "text": "Returns the  address  of the tracker that the request factory is using\nto track new transaction requests. Can then pass the address to create a new instance of a  eac.RequestTracker .  const trackerAddr = requestFactory.getTrackerAddress()\nconst requestTracker = new eac.RequestTracker(trackerAddr, web3)\nrequestTracker.setFactory(requestFactory.address)\n\n// You now have a requestTracker that is the one connected to the\n// requestFactory.", 
            "title": "eac.RequestFactory.getTrackerAddress()"
        }, 
        {
            "location": "/API/requestFactory/#eacrequestfactoryisknownrequestrequestaddr", 
            "text": "Takes a  TxRequest  address and returns a  Promise  that will resolve  true  if the transaction request\nis registed with the factory and  false  if it's not. This function is used\nby clients to verify that the address was registered through the watched\ncontracts.  // Verify that the request is known to the factory we are validating with.\nif (!await requestFactory.isKnownRequest(nextRequestAddress)) {\n    throw new Error(`Encountered unknown address! Please check that you are using the correct contracts JSON file.`)\n}", 
            "title": "eac.RequestFactory.isKnownRequest(requestAddr)"
        }, 
        {
            "location": "/API/requestTracker/", 
            "text": "eac.RequestTracker\n\n\nExposes utilities for interacting with the Request Tracker contract.\n\n\nConstructor\n\n\nCreates a new instance of a \neac.RequestTracker\n and takes two arguments, the first is the \naddress\n of the request tracker contract and the second is a \nweb3\n object.\n\n\nconst requestTracker = new eac.RequestTracker(address, web3)\n\n\n\n\nLike the \neac.RequestFactory\n there are convenience instantiation functions as well.\n\n\neac.RequestTracker.initMainnet(web3)\n\n\nTakes a \nweb3\n object and returns the new instance of a \neac.RequestTracker\n instantiated for \nthe mainnet chain.\n\n\neac.RequestTracker.initRopsten(web3)\n\n\nTakes a \nweb3\n object and returns the new instance of a \neac.RequestTracker\n instatiated for the ropsten\nchain.\n\n\nconst requestTracker = eac.requestTracker.initRopsten(web3)\n\n// You now have a fully instantiated instance which will\n// automatically use the canonical Ropsten contracts.\n\n\n\n\neac.RequestTracker.setFactory(factoryAddr)\n\n\nTakes one argument, the \naddress\n of the \neac.RequestFactory\n that is associated\nwith this request tracker. You \nmust\n set the factory before using any of the methods\noutlined below. This is because the \nRequestTracker\n internally uses the factory address\nto verify inputs.\n\n\neac.RequestTracker.nextFromLeft(blockNum)\n\n\nTakes one argument, a \nblocknumber\n and queries the RequestTracker for the next\nregistered \nTxRequest\n at a windowstart greater than or equal to that block number. Returns a \nPromise\n which resolves to the the transaction request \naddress\n.\n\n\nconst left = await eac.Util.getBlockNumber(web3)\nconst nextRequestAddress = await requestTracker.nextFromLeft(left)\n\nconsole.log(nextRequestAddress)\n// 0x44Df...0Ba\n\n\n\n\neac.RequestTracker.windowStartFor(txRequestAddress)\n\n\nTakes one argument, the \naddress\n of a \nTxRequest\n and returns\na \nPromise\n that will resolve to  the \nwindowStart\n for that transaction request.\n\n\neac.RequestTracker.nextRequest(txRequestAddress)\n\n\nTakes one argument, the \naddress\n of a \nTxRequest\n and returns\na \nPromise\n that resolves to the next\nregistered transaction request address, which can be used to create an instance\nof a \neac.TxRequest\n. Will resolve to a \nNULL_ADDRESS\n if there is not a next\nregistered transaction request.\n\n\nconst nextRequestAddress = await requestTracker.nextRequest(txRequest.address)\n\nif (nextRequestAddress === eac.Constants.NULL_ADDRESS) { \n    console.log('No new requests')\n}", 
            "title": "Request Tracker"
        }, 
        {
            "location": "/API/requestTracker/#eacrequesttracker", 
            "text": "Exposes utilities for interacting with the Request Tracker contract.", 
            "title": "eac.RequestTracker"
        }, 
        {
            "location": "/API/requestTracker/#constructor", 
            "text": "Creates a new instance of a  eac.RequestTracker  and takes two arguments, the first is the  address  of the request tracker contract and the second is a  web3  object.  const requestTracker = new eac.RequestTracker(address, web3)  Like the  eac.RequestFactory  there are convenience instantiation functions as well.", 
            "title": "Constructor"
        }, 
        {
            "location": "/API/requestTracker/#eacrequesttrackerinitmainnetweb3", 
            "text": "Takes a  web3  object and returns the new instance of a  eac.RequestTracker  instantiated for \nthe mainnet chain.", 
            "title": "eac.RequestTracker.initMainnet(web3)"
        }, 
        {
            "location": "/API/requestTracker/#eacrequesttrackerinitropstenweb3", 
            "text": "Takes a  web3  object and returns the new instance of a  eac.RequestTracker  instatiated for the ropsten\nchain.  const requestTracker = eac.requestTracker.initRopsten(web3)\n\n// You now have a fully instantiated instance which will\n// automatically use the canonical Ropsten contracts.", 
            "title": "eac.RequestTracker.initRopsten(web3)"
        }, 
        {
            "location": "/API/requestTracker/#eacrequesttrackersetfactoryfactoryaddr", 
            "text": "Takes one argument, the  address  of the  eac.RequestFactory  that is associated\nwith this request tracker. You  must  set the factory before using any of the methods\noutlined below. This is because the  RequestTracker  internally uses the factory address\nto verify inputs.", 
            "title": "eac.RequestTracker.setFactory(factoryAddr)"
        }, 
        {
            "location": "/API/requestTracker/#eacrequesttrackernextfromleftblocknum", 
            "text": "Takes one argument, a  blocknumber  and queries the RequestTracker for the next\nregistered  TxRequest  at a windowstart greater than or equal to that block number. Returns a  Promise  which resolves to the the transaction request  address .  const left = await eac.Util.getBlockNumber(web3)\nconst nextRequestAddress = await requestTracker.nextFromLeft(left)\n\nconsole.log(nextRequestAddress)\n// 0x44Df...0Ba", 
            "title": "eac.RequestTracker.nextFromLeft(blockNum)"
        }, 
        {
            "location": "/API/requestTracker/#eacrequesttrackerwindowstartfortxrequestaddress", 
            "text": "Takes one argument, the  address  of a  TxRequest  and returns\na  Promise  that will resolve to  the  windowStart  for that transaction request.", 
            "title": "eac.RequestTracker.windowStartFor(txRequestAddress)"
        }, 
        {
            "location": "/API/requestTracker/#eacrequesttrackernextrequesttxrequestaddress", 
            "text": "Takes one argument, the  address  of a  TxRequest  and returns\na  Promise  that resolves to the next\nregistered transaction request address, which can be used to create an instance\nof a  eac.TxRequest . Will resolve to a  NULL_ADDRESS  if there is not a next\nregistered transaction request.  const nextRequestAddress = await requestTracker.nextRequest(txRequest.address)\n\nif (nextRequestAddress === eac.Constants.NULL_ADDRESS) { \n    console.log('No new requests')\n}", 
            "title": "eac.RequestTracker.nextRequest(txRequestAddress)"
        }, 
        {
            "location": "/API/scheduler/", 
            "text": "eac.Scheduler\n\n\nThe Scheduler API of eac.js is a wrapper over both the Timestamp and \nBlock based scheduling APIS of the Ethereum Alarm Clock. It \nattempts to abstract most of the complexity away from the user\nso that you will only have to feed it the variables it wants.\n\n\nConstructor\n\n\nTakes two arguments, a \nweb3\n object and a \nstring\n of the chain name\nto instantiate the contracts for.\n\n\nconst eacScheduler = new eac.Scheduler(web3, 'ropsten')\n\n// Now using the canonical Ropsten contracts for \n// scheduling transactions.\n\n\n\n\neac.Scheduler.getFactoryAddress()\n\n\nReturns a \nPromise\n that resolves to the \naddress\n of the \nRequest Factory being used by the Scheduler.\n\n\neac.Scheduler.initSender(opts)\n\n\nSets the sender for the scheduling transaction. The \nopts\n arguments is \na JSON that contains the \nfrom\n, \ngas\n, and \nvalue\n parameters of an \nEthereum transaction. See the example at the bottom for more context.\n\n\neac.Scheduler.calcEndowment(callGas, callValue, gasPrice, donation, payment)\n\n\nTakes in \nBigNumber\n arguments for \ncallGas\n, \ncallValue\n, \ngasPrice\n, \ndonation\n and\n\npayment\n variables of a \neac.TxRequest\n and returns the a \nBigNumber\n of the required\n\nendowment\n that must be sent to execute the transaction request.\n\n\neac.Scheduler.blockSchedule(toAddress, callData, callGas, callValue, windowSize, windowStart, gasPrice, donation, payment, requiredDeposit)\n\n\n\n\ntoAddress\n     - an Ethereum address\n\n\ncallData\n      - hex encoded call data\n\n\ncallGas\n - \nBigNumber\n | String\n\n\ncallValue\n - \nBigNumber\n | String\n\n\nwindowSize\n - \nBigNumber\n | String\n\n\nwindowStart\n - \nBigNumber\n | String\n\n\ngasPrice\n - \nBigNumber\n | String\n\n\ndonation\n - \nBigNumber\n | String\n\n\npayment\n - \nBigNumber\n | String\n\n\nrequiredDeposit\n - \nBigNumber\n | String\n\n\n\n\nReturns a \nPromise\n that will resolve to the \nreceipt\n of the transaction if successful.\n\n\neac.Scheduler.timestampSchedule(toAddress, callData, callGas, callValue, windowSize, windowStart, gasPrice, donation, payment, requiredDeposit)\n\n\n\n\ntoAddress\n     - an Ethereum address\n\n\ncallData\n      - hex encoded call data\n\n\ncallGas\n - \nBigNumber\n | String\n\n\ncallValue\n - \nBigNumber\n | String\n\n\nwindowSize\n - \nBigNumber\n | String\n\n\nwindowStart\n - \nBigNumber\n | String\n\n\ngasPrice\n - \nBigNumber\n | String\n\n\ndonation\n - \nBigNumber\n | String\n\n\npayment\n - \nBigNumber\n | String\n\n\nrequiredDeposit\n - \nBigNumber\n | String\n\n\n\n\nReturns a \nPromise\n that will resolve to the \nreceipt\n of the transaction if successful.", 
            "title": "Scheduler"
        }, 
        {
            "location": "/API/scheduler/#eacscheduler", 
            "text": "The Scheduler API of eac.js is a wrapper over both the Timestamp and \nBlock based scheduling APIS of the Ethereum Alarm Clock. It \nattempts to abstract most of the complexity away from the user\nso that you will only have to feed it the variables it wants.", 
            "title": "eac.Scheduler"
        }, 
        {
            "location": "/API/scheduler/#constructor", 
            "text": "Takes two arguments, a  web3  object and a  string  of the chain name\nto instantiate the contracts for.  const eacScheduler = new eac.Scheduler(web3, 'ropsten')\n\n// Now using the canonical Ropsten contracts for \n// scheduling transactions.", 
            "title": "Constructor"
        }, 
        {
            "location": "/API/scheduler/#eacschedulergetfactoryaddress", 
            "text": "Returns a  Promise  that resolves to the  address  of the \nRequest Factory being used by the Scheduler.", 
            "title": "eac.Scheduler.getFactoryAddress()"
        }, 
        {
            "location": "/API/scheduler/#eacschedulerinitsenderopts", 
            "text": "Sets the sender for the scheduling transaction. The  opts  arguments is \na JSON that contains the  from ,  gas , and  value  parameters of an \nEthereum transaction. See the example at the bottom for more context.", 
            "title": "eac.Scheduler.initSender(opts)"
        }, 
        {
            "location": "/API/scheduler/#eacschedulercalcendowmentcallgas-callvalue-gasprice-donation-payment", 
            "text": "Takes in  BigNumber  arguments for  callGas ,  callValue ,  gasPrice ,  donation  and payment  variables of a  eac.TxRequest  and returns the a  BigNumber  of the required endowment  that must be sent to execute the transaction request.", 
            "title": "eac.Scheduler.calcEndowment(callGas, callValue, gasPrice, donation, payment)"
        }, 
        {
            "location": "/API/scheduler/#eacschedulerblockscheduletoaddress-calldata-callgas-callvalue-windowsize-windowstart-gasprice-donation-payment-requireddeposit", 
            "text": "toAddress      - an Ethereum address  callData       - hex encoded call data  callGas  -  BigNumber  | String  callValue  -  BigNumber  | String  windowSize  -  BigNumber  | String  windowStart  -  BigNumber  | String  gasPrice  -  BigNumber  | String  donation  -  BigNumber  | String  payment  -  BigNumber  | String  requiredDeposit  -  BigNumber  | String   Returns a  Promise  that will resolve to the  receipt  of the transaction if successful.", 
            "title": "eac.Scheduler.blockSchedule(toAddress, callData, callGas, callValue, windowSize, windowStart, gasPrice, donation, payment, requiredDeposit)"
        }, 
        {
            "location": "/API/scheduler/#eacschedulertimestampscheduletoaddress-calldata-callgas-callvalue-windowsize-windowstart-gasprice-donation-payment-requireddeposit", 
            "text": "toAddress      - an Ethereum address  callData       - hex encoded call data  callGas  -  BigNumber  | String  callValue  -  BigNumber  | String  windowSize  -  BigNumber  | String  windowStart  -  BigNumber  | String  gasPrice  -  BigNumber  | String  donation  -  BigNumber  | String  payment  -  BigNumber  | String  requiredDeposit  -  BigNumber  | String   Returns a  Promise  that will resolve to the  receipt  of the transaction if successful.", 
            "title": "eac.Scheduler.timestampSchedule(toAddress, callData, callGas, callValue, windowSize, windowStart, gasPrice, donation, payment, requiredDeposit)"
        }, 
        {
            "location": "/API/txRequest/", 
            "text": "eac.TxRequest\n\n\nThe wrapper class over an instance of a future transaction scheduled\nby the Ethereum Alarm Clock. Opens up getters to retrieve information\nabout the transaction request and methods for important actions.\n\n\nConstructor\n\n\nThe constructor for the \nTxRequest\n class requires two arguments,\nthe \naddress\n of the transaction request and the \nweb3\n object. It will \nreturn a new instance of a \nTxRequest\n.\n\n\nconst txRequest = new eac.TxRequest(address, web3)\n\n// You now have a new transaction request object, the first thing\n// you will likely want to do it is fill its data.\n\n\n\n\neac.TxRequest.fillData()\n\n\nAsync function which will return a \nPromise\n that resolves to \ntrue\n if the \ndata is successfully fetched from the EAC contracts and stored in the \n\nTxRequest\n instance. You will need to call \n.fillData()\n before trying\nto access any of the methods of the transaction request since\nthe data starts out as \nempty\n.\n\n\nconsole.log(txRequest.isClaimed)   // undefined, must call `.fillData() first\nawait txRequest.fillData()\nconsole.log(txRequest.isClaimed)   // true\nconsole.log(txRequest.windowStart) // 2300780\n\n\n\n\neac.TxRequest.refreshData()\n\n\nAsync function that will return a \nPromise\n that resolves to \ntrue\n if the\ndata is successfully refreshed/updated. Use this method after you have already filled\nthe data on a transaction request and want to update its values. For example, you\nmight use it if the transaction request was recently cancelled.\n\n\nconsole.log(txReqeuest.isCancelled) //false\n\nawait txRequest.cancel({\n    from: web3.eth.defaultAccount,\n    value: 0,\n    gas: 3000000,\n    gasPrice: web3.toWei('20', 'gwei')\n})\n\n// Outdated data\nconsole.log(txReqeuest.isCancelled) //false\n\n// Must refresh the data now.\nawait txRequest.refreshData()\nconsole.log(txRequest.isCancelled) //true\n\n\n\n\neac.TxRequest.now()\n\n\nReturns a \nPromise\n that will resolve to the \nblockNumber\n or \ntimestamp\n\nof the latest ethereum block, depnding on the internal \ntemporalUnit\n of\nthe transaction request.\n\n\neac.TxRequest.beforeClaimWindow()\n\n\nReturns a \nPromise\n that will resolve to \ntrue\n if the transaction request\nis not yet in the claim window and \nfalse\n if is after the claim window start. You can check\nthe claim window start time by using the property \neac.TxRequest.claimWindowStart\n.\n\n\neac.TxRequest.inClaimWindow()\n\n\nReturns a \nPromise\n that will resolve to \ntrue\n if the transaction request\nis inside the claim window and \nfalse\n if not. You could also determine this yourself\nusing the property \neac.TxRequest.claimWindowEnd\n which would return the claim window\nend time.\n\n\neac.TxRequest.inFreezePeriod()\n\n\nReturns a \nPromise\n that will resolve to \ntrue\n if the transaction request\nis currently in the freeze (aka lock-down) period and \nfalse\n if not.\n\n\neac.TxRequest.inExecutionWindow()\n\n\nReturns a \nPromise\n that will resolve to \ntrue\n if the transaction request is\ncurrently in the execution window and \nfalse\n if not.\n\n\neac.TxRequest.inReservedWindow()\n\n\nReturns a \nPromise\n that will resolve to \ntrue\n if the transaction request is\ncurrently in the reserved execution window and \nfalse\n if not. The reserved execution\nwindow is the first portion of the execution window which is reserved to be executed\nby the account that has claimed it in the previous claim window.\n\n\neac.TxRequest.afterExecutionWindow()\n\n\nReturns a \nPromise\n that will resolve to \ntrue\n if the transaction request is\ncurrently after the execution window and \nfalse\n if not.\n\n\neac.TxRequest.claimedBy\n\n\nProperty that returns the \naccount\n that has claimed the transaction request.\n\n\neac.TxRequest.isClaimed\n\n\nProperty that returns \ntrue\n if the transaction request is claimed.\n\n\neac.TxRequest.isClaimedBy(account)\n\n\nMethod that returns \ntrue\n if the transaction request is claimed by\nthe passed in \naccount\n argument.\n\n\neac.TxRequest.requiredDeposit\n\n\nProperty that returns a \nBigNumber\n containing the required deposit\nthat must be sent with the \nclaim()\n transaction in order for\nan account to claim a transaction request.\n\n\neac.TxRequest.claimPaymentModifier()\n\n\nMethod that returns a \nPromise\n that will resolve to a \nBigNumber\n containing\nthe payment modifier for the current time during the claim period. The claim\npayment starts at 0% and increases to 100% during the claim window. This method\nwill return that number.\n\n\neac.TxRequest.isCancelled\n\n\nProperty that returns \ntrue\n if the transaction request has been cancelled\nby its owner.\n\n\neac.TxRequest.wasCalled\n\n\nProperty that returns \ntrue\n if the transaction request has already\nbeen executed.\n\n\neac.TxRequest.owner\n\n\nProperty that returns the \naddress\n of the owner/creator of the transaction request.\n\n\neac.TxRequest.toAddress\n\n\nReturns the \naddress\n that the transaction request will be send to when it is executed.\n\n\neac.TxRequest.callGas\n\n\nReturns the a \nBigNumber\n containing the \ncallGas\n in wei that the transaction request will\nsend when its executed.\n\n\neac.TxRequest.callValue\n\n\nReturns the a \nBigNumber\n containing the \ncallValue\n in wei that the transaction request will\nsend when its executed.\n\n\neac.TxRequest.gasPrice\n\n\nReturns the a \nBigNumber\n containing the \ngasPrice\n in wei that the transaction request will\nsend when its executed.\n\n\neac.TxRequest.donation\n\n\nReturns the a \nBigNumber\n containing the \ndonation\n in wei that the transaction request will\nsend when its executed.\n\n\neac.TxRequest.payment\n\n\nReturns the a \nBigNumber\n containing the \npayment\n in wei that the transaction request will\nsend when its executed.\n\n\neac.TxRequest.callData()\n\n\nReturns a \nPromise\n that will resolve to the \ncallData\n that the transaction request\nwill send when its executed.\n\n\neac.TxRequest.claim(params)\n\n\nParams\n is a standard ethereum transaction object passed in as JSON and including the variables, \nfrom\n, \ngas\n, \ngasPrice\n, and \nvalue\n. Will attempt to claim a transaction request and returns a \nPromise\n\nthat will resolve to the \nreceipt\n of the transaction if it's successful.\n\n\neac.TxRequest.execute(params)\n\n\nParams\n is a standard ethereum transaction object passed in as JSON and including the variables, \nfrom\n, \ngas\n, \ngasPrice\n, and \nvalue\n. Will attempt to execute a transaction request and returns a \nPromise\n\nthat will resolve to the \nreceipt\n of the transaction if it's successful.\n\n\neac.TxRequest.cancel(params)\n\n\nParams\n is a standard ethereum transaction object passed in as JSON and including the variables, \nfrom\n, \ngas\n, \ngasPrice\n, and \nvalue\n. Will attempt to cancel a transaction request and returns a \nPromise\n\nthat will resolve to the \nreceipt\n of the transaction if it's successful.", 
            "title": "Transaction Request"
        }, 
        {
            "location": "/API/txRequest/#eactxrequest", 
            "text": "The wrapper class over an instance of a future transaction scheduled\nby the Ethereum Alarm Clock. Opens up getters to retrieve information\nabout the transaction request and methods for important actions.", 
            "title": "eac.TxRequest"
        }, 
        {
            "location": "/API/txRequest/#constructor", 
            "text": "The constructor for the  TxRequest  class requires two arguments,\nthe  address  of the transaction request and the  web3  object. It will \nreturn a new instance of a  TxRequest .  const txRequest = new eac.TxRequest(address, web3)\n\n// You now have a new transaction request object, the first thing\n// you will likely want to do it is fill its data.", 
            "title": "Constructor"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestfilldata", 
            "text": "Async function which will return a  Promise  that resolves to  true  if the \ndata is successfully fetched from the EAC contracts and stored in the  TxRequest  instance. You will need to call  .fillData()  before trying\nto access any of the methods of the transaction request since\nthe data starts out as  empty .  console.log(txRequest.isClaimed)   // undefined, must call `.fillData() first\nawait txRequest.fillData()\nconsole.log(txRequest.isClaimed)   // true\nconsole.log(txRequest.windowStart) // 2300780", 
            "title": "eac.TxRequest.fillData()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestrefreshdata", 
            "text": "Async function that will return a  Promise  that resolves to  true  if the\ndata is successfully refreshed/updated. Use this method after you have already filled\nthe data on a transaction request and want to update its values. For example, you\nmight use it if the transaction request was recently cancelled.  console.log(txReqeuest.isCancelled) //false\n\nawait txRequest.cancel({\n    from: web3.eth.defaultAccount,\n    value: 0,\n    gas: 3000000,\n    gasPrice: web3.toWei('20', 'gwei')\n})\n\n// Outdated data\nconsole.log(txReqeuest.isCancelled) //false\n\n// Must refresh the data now.\nawait txRequest.refreshData()\nconsole.log(txRequest.isCancelled) //true", 
            "title": "eac.TxRequest.refreshData()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestnow", 
            "text": "Returns a  Promise  that will resolve to the  blockNumber  or  timestamp \nof the latest ethereum block, depnding on the internal  temporalUnit  of\nthe transaction request.", 
            "title": "eac.TxRequest.now()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestbeforeclaimwindow", 
            "text": "Returns a  Promise  that will resolve to  true  if the transaction request\nis not yet in the claim window and  false  if is after the claim window start. You can check\nthe claim window start time by using the property  eac.TxRequest.claimWindowStart .", 
            "title": "eac.TxRequest.beforeClaimWindow()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestinclaimwindow", 
            "text": "Returns a  Promise  that will resolve to  true  if the transaction request\nis inside the claim window and  false  if not. You could also determine this yourself\nusing the property  eac.TxRequest.claimWindowEnd  which would return the claim window\nend time.", 
            "title": "eac.TxRequest.inClaimWindow()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestinfreezeperiod", 
            "text": "Returns a  Promise  that will resolve to  true  if the transaction request\nis currently in the freeze (aka lock-down) period and  false  if not.", 
            "title": "eac.TxRequest.inFreezePeriod()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestinexecutionwindow", 
            "text": "Returns a  Promise  that will resolve to  true  if the transaction request is\ncurrently in the execution window and  false  if not.", 
            "title": "eac.TxRequest.inExecutionWindow()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestinreservedwindow", 
            "text": "Returns a  Promise  that will resolve to  true  if the transaction request is\ncurrently in the reserved execution window and  false  if not. The reserved execution\nwindow is the first portion of the execution window which is reserved to be executed\nby the account that has claimed it in the previous claim window.", 
            "title": "eac.TxRequest.inReservedWindow()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestafterexecutionwindow", 
            "text": "Returns a  Promise  that will resolve to  true  if the transaction request is\ncurrently after the execution window and  false  if not.", 
            "title": "eac.TxRequest.afterExecutionWindow()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestclaimedby", 
            "text": "Property that returns the  account  that has claimed the transaction request.", 
            "title": "eac.TxRequest.claimedBy"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestisclaimed", 
            "text": "Property that returns  true  if the transaction request is claimed.", 
            "title": "eac.TxRequest.isClaimed"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestisclaimedbyaccount", 
            "text": "Method that returns  true  if the transaction request is claimed by\nthe passed in  account  argument.", 
            "title": "eac.TxRequest.isClaimedBy(account)"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestrequireddeposit", 
            "text": "Property that returns a  BigNumber  containing the required deposit\nthat must be sent with the  claim()  transaction in order for\nan account to claim a transaction request.", 
            "title": "eac.TxRequest.requiredDeposit"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestclaimpaymentmodifier", 
            "text": "Method that returns a  Promise  that will resolve to a  BigNumber  containing\nthe payment modifier for the current time during the claim period. The claim\npayment starts at 0% and increases to 100% during the claim window. This method\nwill return that number.", 
            "title": "eac.TxRequest.claimPaymentModifier()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestiscancelled", 
            "text": "Property that returns  true  if the transaction request has been cancelled\nby its owner.", 
            "title": "eac.TxRequest.isCancelled"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestwascalled", 
            "text": "Property that returns  true  if the transaction request has already\nbeen executed.", 
            "title": "eac.TxRequest.wasCalled"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestowner", 
            "text": "Property that returns the  address  of the owner/creator of the transaction request.", 
            "title": "eac.TxRequest.owner"
        }, 
        {
            "location": "/API/txRequest/#eactxrequesttoaddress", 
            "text": "Returns the  address  that the transaction request will be send to when it is executed.", 
            "title": "eac.TxRequest.toAddress"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestcallgas", 
            "text": "Returns the a  BigNumber  containing the  callGas  in wei that the transaction request will\nsend when its executed.", 
            "title": "eac.TxRequest.callGas"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestcallvalue", 
            "text": "Returns the a  BigNumber  containing the  callValue  in wei that the transaction request will\nsend when its executed.", 
            "title": "eac.TxRequest.callValue"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestgasprice", 
            "text": "Returns the a  BigNumber  containing the  gasPrice  in wei that the transaction request will\nsend when its executed.", 
            "title": "eac.TxRequest.gasPrice"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestdonation", 
            "text": "Returns the a  BigNumber  containing the  donation  in wei that the transaction request will\nsend when its executed.", 
            "title": "eac.TxRequest.donation"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestpayment", 
            "text": "Returns the a  BigNumber  containing the  payment  in wei that the transaction request will\nsend when its executed.", 
            "title": "eac.TxRequest.payment"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestcalldata", 
            "text": "Returns a  Promise  that will resolve to the  callData  that the transaction request\nwill send when its executed.", 
            "title": "eac.TxRequest.callData()"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestclaimparams", 
            "text": "Params  is a standard ethereum transaction object passed in as JSON and including the variables,  from ,  gas ,  gasPrice , and  value . Will attempt to claim a transaction request and returns a  Promise \nthat will resolve to the  receipt  of the transaction if it's successful.", 
            "title": "eac.TxRequest.claim(params)"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestexecuteparams", 
            "text": "Params  is a standard ethereum transaction object passed in as JSON and including the variables,  from ,  gas ,  gasPrice , and  value . Will attempt to execute a transaction request and returns a  Promise \nthat will resolve to the  receipt  of the transaction if it's successful.", 
            "title": "eac.TxRequest.execute(params)"
        }, 
        {
            "location": "/API/txRequest/#eactxrequestcancelparams", 
            "text": "Params  is a standard ethereum transaction object passed in as JSON and including the variables,  from ,  gas ,  gasPrice , and  value . Will attempt to cancel a transaction request and returns a  Promise \nthat will resolve to the  receipt  of the transaction if it's successful.", 
            "title": "eac.TxRequest.cancel(params)"
        }, 
        {
            "location": "/API/util/", 
            "text": "eac.Util\n\n\nA collection of utility functions. Only of interest to the most curious of \ndevelopers who are best directed to the \nsource\n.", 
            "title": "Util"
        }, 
        {
            "location": "/API/util/#eacutil", 
            "text": "A collection of utility functions. Only of interest to the most curious of \ndevelopers who are best directed to the  source .", 
            "title": "eac.Util"
        }, 
        {
            "location": "/GUI_Implementer_Guide/", 
            "text": "Ethereum Alarm Clock GUI Implementation Guide\n\n\nThis guide is an attempt to provide information to ease the process of an implementation of a graphical front-end on the Ethereum Alarm Clock service. It should be a document that you can consult to understand what parameters you need to include and the user cases to cover while building your interface.\n\n\nWhat will be implemented?\n\n\nA graphical interface to the Ethereum Alarm Clock. User functionalities will include the ability to schedule a transaction in a cohesive flow. It may also include the ability to manually execute a transaction request (althought for the most past this will be done more efficiently by clients such as \neac.js\n)\n\n\nBasics\n\n\nThe ethereum alarm clock consists of a collection of smart contracts that interoperate with each other on-chain. Whenever a user schedules a new transaction, it will use these contracts to deploy a new contract that contains all of the execution data set by the user. The contracts keep track of this \ntransaction request\n in a database contract that exposes a public API to be queriable by off-chain code.\n\n\nServers that are running an execution client will be scanning the blockchain for scheduled \ntransaction requests\n and sending claim or execution transactions to them. Clients will be doing most of the execution work \"behind the scenes\" for users and ideally, they will never have to worry about their transaction being executed on time.\n\n\nIn order to provide incentive to execution clients, when users schedule transactions they will include a \npayment\n variable.\n\n\nIf you would like a complete introduction to the Ethereum Alarm Clock infrastructure, we recommend the official docs.\n\n\nSchedulers\n\n\nYou will be working with the high-level APIs of the Scheduler contracts. There are two types of Scheduler, a \nTimestampScheduler\n and a \nBlockScheduler\n. The only difference between these two is the unit of time that each accepts for its scheduling paremeters. As you might guess, the \nTimestampScheduler\n requires all input to be as a \nUnix timestamp\n while the \nBlockScheduler\n takes in input as Ethereum block numbers. Otherwise, both Schedulers have the same public function \nschedule()\n to accept input. Here is the Solidity interface:\n\n\nfunction schedule(address   _toAddress,\n                  bytes     _callData,\n                  uint[8]   _uintArgs)\n    doReset\n    public payable returns (address);\n\n\n\n\nSchedule params\n\n\nThe schedule function takes three parameters, an Ethereum address, an array of bytes (a Javascript \nBuffer\n), and an array of eight unsigned integers. The eight unsigned integers are:\n\n\n\n\n_uintArgs [0] The \ncallGas\n to be sent with the scheduled transaction.\n\n\n_uintArgs [1] The \ncallValue\n to be sent with the scheduled transaction.\n\n\n_uintArgs [2] The execution \nwindowSize\n.\n\n\n_uintArgs [3] The (block or timestamp) of the execution \nwindowStart\n.\n\n\n_uintArgs [4] The \ngasPrice\n which will be used to execute this transaction.\n\n\n_uintArgs [5] The \ndonation\n value attached to this transaction.\n\n\n_uintArgs [6] The \npayment\n value attached to this transaction.\n\n\n_uintArgs [7] The \nrequiredDeposit\n to claim this transaction.\n\n\n\n\nThe scheduling party must also send enough value to cover the \nendowment\n of the transaction request. The \nendowment\n is calculated like so:\n\n\nendowment = payment + donation * 2 + callGas * gasPrice + 180000 * gasPrice + callValue\n\n\n\n\nThe \nendowment\n is required because the scheduler of the transaction must pay all the gas costs, as well as cover the value and the \npayment\n and \ndonation\n costs up front.  \n\n\nValidation\n\n\nThe Schedulers will use the \nRequestFactory\n contract to perform some verification checks on the input it recieves and bubble up a \nValidationError\n event if one is encountered. The front-end GUI should be able to read these events if they happen and notify the use why their transaction was not able to go through. However, it may be better if the front-end code employed validation checks to prevent the error ever reaching the blockchain.\n\n\nSome verification check you will need to be aware of include:\n\n\nInsufficient Endowment\n\n\nThe amount sent in the transaction must be \nat least\n the sum computed as the \nendowment\n. \n\n\nCall Gas too High\n\n\nThe maximum callGas sent with the transaction is the \ncurrent_network_gasLimit - 140000\n where \n140000\n is the gas overhead of execution.\n\n\nEmpty To Address\n\n\nThe \ntoAddress\n cannot be a null address \n0x0000000000000000000000000000000000000000\n\n\nFor a full list of \nValidationError\n see \nthis page\n of the docs.\n\n\nNecessary Options\n\n\nYou will need to present an option for the user to switch between block-based\nscheduling and timestamp-based scheduling. This could be accomplished by the\nimplementation of a switch or checkbox, or perhaps a drop-down menu.\n\n\nTo be continued...", 
            "title": "GUI Implementer Guide"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#ethereum-alarm-clock-gui-implementation-guide", 
            "text": "This guide is an attempt to provide information to ease the process of an implementation of a graphical front-end on the Ethereum Alarm Clock service. It should be a document that you can consult to understand what parameters you need to include and the user cases to cover while building your interface.", 
            "title": "Ethereum Alarm Clock GUI Implementation Guide"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#what-will-be-implemented", 
            "text": "A graphical interface to the Ethereum Alarm Clock. User functionalities will include the ability to schedule a transaction in a cohesive flow. It may also include the ability to manually execute a transaction request (althought for the most past this will be done more efficiently by clients such as  eac.js )", 
            "title": "What will be implemented?"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#basics", 
            "text": "The ethereum alarm clock consists of a collection of smart contracts that interoperate with each other on-chain. Whenever a user schedules a new transaction, it will use these contracts to deploy a new contract that contains all of the execution data set by the user. The contracts keep track of this  transaction request  in a database contract that exposes a public API to be queriable by off-chain code.  Servers that are running an execution client will be scanning the blockchain for scheduled  transaction requests  and sending claim or execution transactions to them. Clients will be doing most of the execution work \"behind the scenes\" for users and ideally, they will never have to worry about their transaction being executed on time.  In order to provide incentive to execution clients, when users schedule transactions they will include a  payment  variable.  If you would like a complete introduction to the Ethereum Alarm Clock infrastructure, we recommend the official docs.", 
            "title": "Basics"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#schedulers", 
            "text": "You will be working with the high-level APIs of the Scheduler contracts. There are two types of Scheduler, a  TimestampScheduler  and a  BlockScheduler . The only difference between these two is the unit of time that each accepts for its scheduling paremeters. As you might guess, the  TimestampScheduler  requires all input to be as a  Unix timestamp  while the  BlockScheduler  takes in input as Ethereum block numbers. Otherwise, both Schedulers have the same public function  schedule()  to accept input. Here is the Solidity interface:  function schedule(address   _toAddress,\n                  bytes     _callData,\n                  uint[8]   _uintArgs)\n    doReset\n    public payable returns (address);", 
            "title": "Schedulers"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#schedule-params", 
            "text": "The schedule function takes three parameters, an Ethereum address, an array of bytes (a Javascript  Buffer ), and an array of eight unsigned integers. The eight unsigned integers are:   _uintArgs [0] The  callGas  to be sent with the scheduled transaction.  _uintArgs [1] The  callValue  to be sent with the scheduled transaction.  _uintArgs [2] The execution  windowSize .  _uintArgs [3] The (block or timestamp) of the execution  windowStart .  _uintArgs [4] The  gasPrice  which will be used to execute this transaction.  _uintArgs [5] The  donation  value attached to this transaction.  _uintArgs [6] The  payment  value attached to this transaction.  _uintArgs [7] The  requiredDeposit  to claim this transaction.   The scheduling party must also send enough value to cover the  endowment  of the transaction request. The  endowment  is calculated like so:  endowment = payment + donation * 2 + callGas * gasPrice + 180000 * gasPrice + callValue  The  endowment  is required because the scheduler of the transaction must pay all the gas costs, as well as cover the value and the  payment  and  donation  costs up front.", 
            "title": "Schedule params"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#validation", 
            "text": "The Schedulers will use the  RequestFactory  contract to perform some verification checks on the input it recieves and bubble up a  ValidationError  event if one is encountered. The front-end GUI should be able to read these events if they happen and notify the use why their transaction was not able to go through. However, it may be better if the front-end code employed validation checks to prevent the error ever reaching the blockchain.  Some verification check you will need to be aware of include:", 
            "title": "Validation"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#insufficient-endowment", 
            "text": "The amount sent in the transaction must be  at least  the sum computed as the  endowment .", 
            "title": "Insufficient Endowment"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#call-gas-too-high", 
            "text": "The maximum callGas sent with the transaction is the  current_network_gasLimit - 140000  where  140000  is the gas overhead of execution.", 
            "title": "Call Gas too High"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#empty-to-address", 
            "text": "The  toAddress  cannot be a null address  0x0000000000000000000000000000000000000000  For a full list of  ValidationError  see  this page  of the docs.", 
            "title": "Empty To Address"
        }, 
        {
            "location": "/GUI_Implementer_Guide/#necessary-options", 
            "text": "You will need to present an option for the user to switch between block-based\nscheduling and timestamp-based scheduling. This could be accomplished by the\nimplementation of a switch or checkbox, or perhaps a drop-down menu.  To be continued...", 
            "title": "Necessary Options"
        }, 
        {
            "location": "/Changelog/", 
            "text": "Changelog\n\n\n0.9.8", 
            "title": "Changelog"
        }, 
        {
            "location": "/Changelog/#changelog", 
            "text": "", 
            "title": "Changelog"
        }, 
        {
            "location": "/Changelog/#098", 
            "text": "", 
            "title": "0.9.8"
        }
    ]
}